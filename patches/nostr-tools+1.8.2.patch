diff --git a/node_modules/nostr-tools/lib/esm/nostr.mjs b/node_modules/nostr-tools/lib/esm/nostr.mjs
index fe9f629..974ee7d 100644
--- a/node_modules/nostr-tools/lib/esm/nostr.mjs
+++ b/node_modules/nostr-tools/lib/esm/nostr.mjs
@@ -1,3 +1,5 @@
+import { TextEncoder, TextDecoder } from "text-encoding";
+
 var __defProp = Object.defineProperty;
 var __export = (target, all) => {
   for (var name in all)
@@ -24,16 +26,18 @@ __export(utils_exports, {
   insertEventIntoDescendingList: () => insertEventIntoDescendingList,
   normalizeURL: () => normalizeURL,
   utf8Decoder: () => utf8Decoder,
-  utf8Encoder: () => utf8Encoder
+  utf8Encoder: () => utf8Encoder,
 });
 var utf8Decoder = new TextDecoder("utf-8");
 var utf8Encoder = new TextEncoder();
 function normalizeURL(url) {
   let p = new URL(url);
   p.pathname = p.pathname.replace(/\/+/g, "/");
-  if (p.pathname.endsWith("/"))
-    p.pathname = p.pathname.slice(0, -1);
-  if (p.port === "80" && p.protocol === "ws:" || p.port === "443" && p.protocol === "wss:")
+  if (p.pathname.endsWith("/")) p.pathname = p.pathname.slice(0, -1);
+  if (
+    (p.port === "80" && p.protocol === "ws:") ||
+    (p.port === "443" && p.protocol === "wss:")
+  )
     p.port = "";
   p.searchParams.sort();
   p.hash = "";
@@ -70,7 +74,7 @@ function insertEventIntoDescendingList(sortedArray, event) {
     return [
       ...sortedArray.slice(0, position),
       event,
-      ...sortedArray.slice(position)
+      ...sortedArray.slice(position),
     ];
   }
   return sortedArray;
@@ -106,7 +110,7 @@ function insertEventIntoAscendingList(sortedArray, event) {
     return [
       ...sortedArray.slice(0, position),
       event,
-      ...sortedArray.slice(position)
+      ...sortedArray.slice(position),
     ];
   }
   return sortedArray;
@@ -114,24 +118,24 @@ function insertEventIntoAscendingList(sortedArray, event) {
 
 // event.ts
 var Kind = /* @__PURE__ */ ((Kind2) => {
-  Kind2[Kind2["Metadata"] = 0] = "Metadata";
-  Kind2[Kind2["Text"] = 1] = "Text";
-  Kind2[Kind2["RecommendRelay"] = 2] = "RecommendRelay";
-  Kind2[Kind2["Contacts"] = 3] = "Contacts";
-  Kind2[Kind2["EncryptedDirectMessage"] = 4] = "EncryptedDirectMessage";
-  Kind2[Kind2["EventDeletion"] = 5] = "EventDeletion";
-  Kind2[Kind2["Reaction"] = 7] = "Reaction";
-  Kind2[Kind2["ChannelCreation"] = 40] = "ChannelCreation";
-  Kind2[Kind2["ChannelMetadata"] = 41] = "ChannelMetadata";
-  Kind2[Kind2["ChannelMessage"] = 42] = "ChannelMessage";
-  Kind2[Kind2["ChannelHideMessage"] = 43] = "ChannelHideMessage";
-  Kind2[Kind2["ChannelMuteUser"] = 44] = "ChannelMuteUser";
-  Kind2[Kind2["Report"] = 1984] = "Report";
-  Kind2[Kind2["ZapRequest"] = 9734] = "ZapRequest";
-  Kind2[Kind2["Zap"] = 9735] = "Zap";
-  Kind2[Kind2["RelayList"] = 10002] = "RelayList";
-  Kind2[Kind2["ClientAuth"] = 22242] = "ClientAuth";
-  Kind2[Kind2["Article"] = 30023] = "Article";
+  Kind2[(Kind2["Metadata"] = 0)] = "Metadata";
+  Kind2[(Kind2["Text"] = 1)] = "Text";
+  Kind2[(Kind2["RecommendRelay"] = 2)] = "RecommendRelay";
+  Kind2[(Kind2["Contacts"] = 3)] = "Contacts";
+  Kind2[(Kind2["EncryptedDirectMessage"] = 4)] = "EncryptedDirectMessage";
+  Kind2[(Kind2["EventDeletion"] = 5)] = "EventDeletion";
+  Kind2[(Kind2["Reaction"] = 7)] = "Reaction";
+  Kind2[(Kind2["ChannelCreation"] = 40)] = "ChannelCreation";
+  Kind2[(Kind2["ChannelMetadata"] = 41)] = "ChannelMetadata";
+  Kind2[(Kind2["ChannelMessage"] = 42)] = "ChannelMessage";
+  Kind2[(Kind2["ChannelHideMessage"] = 43)] = "ChannelHideMessage";
+  Kind2[(Kind2["ChannelMuteUser"] = 44)] = "ChannelMuteUser";
+  Kind2[(Kind2["Report"] = 1984)] = "Report";
+  Kind2[(Kind2["ZapRequest"] = 9734)] = "ZapRequest";
+  Kind2[(Kind2["Zap"] = 9735)] = "Zap";
+  Kind2[(Kind2["RelayList"] = 10002)] = "RelayList";
+  Kind2[(Kind2["ClientAuth"] = 22242)] = "ClientAuth";
+  Kind2[(Kind2["Article"] = 30023)] = "Article";
   return Kind2;
 })(Kind || {});
 function getBlankEvent() {
@@ -139,7 +143,7 @@ function getBlankEvent() {
     kind: 255,
     content: "",
     tags: [],
-    created_at: 0
+    created_at: 0,
   };
 }
 function finishEvent(t, privateKey) {
@@ -158,7 +162,7 @@ function serializeEvent(evt) {
     evt.created_at,
     evt.kind,
     evt.tags,
-    evt.content
+    evt.content,
   ]);
 }
 function getEventHash(event) {
@@ -166,27 +170,18 @@ function getEventHash(event) {
   return secp256k12.utils.bytesToHex(eventHash);
 }
 function validateEvent(event) {
-  if (typeof event !== "object")
-    return false;
-  if (typeof event.kind !== "number")
-    return false;
-  if (typeof event.content !== "string")
-    return false;
-  if (typeof event.created_at !== "number")
-    return false;
-  if (typeof event.pubkey !== "string")
-    return false;
-  if (!event.pubkey.match(/^[a-f0-9]{64}$/))
-    return false;
-  if (!Array.isArray(event.tags))
-    return false;
+  if (typeof event !== "object") return false;
+  if (typeof event.kind !== "number") return false;
+  if (typeof event.content !== "string") return false;
+  if (typeof event.created_at !== "number") return false;
+  if (typeof event.pubkey !== "string") return false;
+  if (!event.pubkey.match(/^[a-f0-9]{64}$/)) return false;
+  if (!Array.isArray(event.tags)) return false;
   for (let i = 0; i < event.tags.length; i++) {
     let tag = event.tags[i];
-    if (!Array.isArray(tag))
-      return false;
+    if (!Array.isArray(tag)) return false;
     for (let j = 0; j < tag.length; j++) {
-      if (typeof tag[j] === "object")
-        return false;
+      if (typeof tag[j] === "object") return false;
     }
   }
   return true;
@@ -206,32 +201,30 @@ function signEvent(event, key) {
 
 // filter.ts
 function matchFilter(filter, event) {
-  if (filter.ids && filter.ids.indexOf(event.id) === -1)
-    return false;
-  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1)
-    return false;
+  if (filter.ids && filter.ids.indexOf(event.id) === -1) return false;
+  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) return false;
   if (filter.authors && filter.authors.indexOf(event.pubkey) === -1)
     return false;
   for (let f in filter) {
     if (f[0] === "#") {
       let tagName = f.slice(1);
       let values = filter[`#${tagName}`];
-      if (values && !event.tags.find(
-        ([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1
-      ))
+      if (
+        values &&
+        !event.tags.find(
+          ([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1
+        )
+      )
         return false;
     }
   }
-  if (filter.since && event.created_at < filter.since)
-    return false;
-  if (filter.until && event.created_at >= filter.until)
-    return false;
+  if (filter.since && event.created_at < filter.since) return false;
+  if (filter.until && event.created_at >= filter.until) return false;
   return true;
 }
 function matchFilters(filters, event) {
   for (let i = 0; i < filters.length; i++) {
-    if (matchFilter(filters[i], event))
-      return true;
+    if (matchFilter(filters[i], event)) return true;
   }
   return false;
 }
@@ -244,7 +237,7 @@ __export(fakejson_exports, {
   getSubscriptionId: () => getSubscriptionId,
   matchEventId: () => matchEventId,
   matchEventKind: () => matchEventKind,
-  matchEventPubkey: () => matchEventPubkey
+  matchEventPubkey: () => matchEventPubkey,
 });
 function getHex64(json, field) {
   let len = field.length + 3;
@@ -261,15 +254,12 @@ function getInt(json, field) {
 }
 function getSubscriptionId(json) {
   let idx = json.slice(0, 22).indexOf(`"EVENT"`);
-  if (idx === -1)
-    return null;
+  if (idx === -1) return null;
   let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
-  if (pstart === -1)
-    return null;
+  if (pstart === -1) return null;
   let start = idx + 7 + 1 + pstart;
   let pend = json.slice(start + 1, 80).indexOf(`"`);
-  if (pend === -1)
-    return null;
+  if (pend === -1) return null;
   let end = start + 1 + pend;
   return json.slice(start + 1, end);
 }
@@ -292,14 +282,13 @@ function relayInit(url, options = {}) {
     connect: [],
     disconnect: [],
     error: [],
-    notice: []
+    notice: [],
   };
   var subListeners = {};
   var pubListeners = {};
   var connectionPromise;
   async function connectRelay() {
-    if (connectionPromise)
-      return connectionPromise;
+    if (connectionPromise) return connectionPromise;
     connectionPromise = new Promise((resolve, reject) => {
       try {
         ws = new WebSocket(url);
@@ -334,12 +323,15 @@ function relayInit(url, options = {}) {
           return;
         }
         var json = incomingMessageQueue.shift();
-        if (!json)
-          return;
+        if (!json) return;
         let subid = getSubscriptionId(json);
         if (subid) {
           let so = openSubs[subid];
-          if (so && so.alreadyHaveEvent && so.alreadyHaveEvent(getHex64(json, "id"), url)) {
+          if (
+            so &&
+            so.alreadyHaveEvent &&
+            so.alreadyHaveEvent(getHex64(json, "id"), url)
+          ) {
             return;
           }
         }
@@ -349,7 +341,12 @@ function relayInit(url, options = {}) {
             case "EVENT":
               let id = data[1];
               let event = data[2];
-              if (validateEvent(event) && openSubs[id] && (openSubs[id].skipVerification || verifySignature(event)) && matchFilters(openSubs[id].filters, event)) {
+              if (
+                validateEvent(event) &&
+                openSubs[id] &&
+                (openSubs[id].skipVerification || verifySignature(event)) &&
+                matchFilters(openSubs[id].filters, event)
+              ) {
                 openSubs[id];
                 (subListeners[id]?.event || []).forEach((cb) => cb(event));
               }
@@ -367,10 +364,8 @@ function relayInit(url, options = {}) {
               let ok = data[2];
               let reason = data[3] || "";
               if (id2 in pubListeners) {
-                if (ok)
-                  pubListeners[id2].ok.forEach((cb) => cb());
-                else
-                  pubListeners[id2].failed.forEach((cb) => cb(reason));
+                if (ok) pubListeners[id2].ok.forEach((cb) => cb());
+                else pubListeners[id2].failed.forEach((cb) => cb(reason));
                 pubListeners[id2].ok = [];
                 pubListeners[id2].failed = [];
               }
@@ -392,8 +387,7 @@ function relayInit(url, options = {}) {
     return ws?.readyState === 1;
   }
   async function connect() {
-    if (connected())
-      return;
+    if (connected()) return;
     await connectRelay();
   }
   async function trySend(params) {
@@ -410,25 +404,29 @@ function relayInit(url, options = {}) {
       console.log(err);
     }
   }
-  const sub = (filters, {
-    skipVerification = false,
-    alreadyHaveEvent = null,
-    id = Math.random().toString().slice(2)
-  } = {}) => {
+  const sub = (
+    filters,
+    {
+      skipVerification = false,
+      alreadyHaveEvent = null,
+      id = Math.random().toString().slice(2),
+    } = {}
+  ) => {
     let subid = id;
     openSubs[subid] = {
       id: subid,
       filters,
       skipVerification,
-      alreadyHaveEvent
+      alreadyHaveEvent,
     };
     trySend(["REQ", subid, ...filters]);
     return {
-      sub: (newFilters, newOpts = {}) => sub(newFilters || filters, {
-        skipVerification: newOpts.skipVerification || skipVerification,
-        alreadyHaveEvent: newOpts.alreadyHaveEvent || alreadyHaveEvent,
-        id: subid
-      }),
+      sub: (newFilters, newOpts = {}) =>
+        sub(newFilters || filters, {
+          skipVerification: newOpts.skipVerification || skipVerification,
+          alreadyHaveEvent: newOpts.alreadyHaveEvent || alreadyHaveEvent,
+          id: subid,
+        }),
       unsub: () => {
         delete openSubs[subid];
         delete subListeners[subid];
@@ -437,16 +435,15 @@ function relayInit(url, options = {}) {
       on: (type, cb) => {
         subListeners[subid] = subListeners[subid] || {
           event: [],
-          eose: []
+          eose: [],
         };
         subListeners[subid][type].push(cb);
       },
       off: (type, cb) => {
         let listeners2 = subListeners[subid];
         let idx = listeners2[type].indexOf(cb);
-        if (idx >= 0)
-          listeners2[type].splice(idx, 1);
-      }
+        if (idx >= 0) listeners2[type].splice(idx, 1);
+      },
     };
   };
   return {
@@ -455,64 +452,61 @@ function relayInit(url, options = {}) {
     on: (type, cb) => {
       listeners[type].push(cb);
       if (type === "connect" && ws?.readyState === 1) {
-        ;
         cb();
       }
     },
     off: (type, cb) => {
       let index = listeners[type].indexOf(cb);
-      if (index !== -1)
-        listeners[type].splice(index, 1);
+      if (index !== -1) listeners[type].splice(index, 1);
     },
-    list: (filters, opts) => new Promise((resolve) => {
-      let s = sub(filters, opts);
-      let events = [];
-      let timeout = setTimeout(() => {
-        s.unsub();
-        resolve(events);
-      }, listTimeout);
-      s.on("eose", () => {
-        s.unsub();
-        clearTimeout(timeout);
-        resolve(events);
-      });
-      s.on("event", (event) => {
-        events.push(event);
-      });
-    }),
-    get: (filter, opts) => new Promise((resolve) => {
-      let s = sub([filter], opts);
-      let timeout = setTimeout(() => {
-        s.unsub();
-        resolve(null);
-      }, getTimeout);
-      s.on("event", (event) => {
-        s.unsub();
-        clearTimeout(timeout);
-        resolve(event);
-      });
-    }),
+    list: (filters, opts) =>
+      new Promise((resolve) => {
+        let s = sub(filters, opts);
+        let events = [];
+        let timeout = setTimeout(() => {
+          s.unsub();
+          resolve(events);
+        }, listTimeout);
+        s.on("eose", () => {
+          s.unsub();
+          clearTimeout(timeout);
+          resolve(events);
+        });
+        s.on("event", (event) => {
+          events.push(event);
+        });
+      }),
+    get: (filter, opts) =>
+      new Promise((resolve) => {
+        let s = sub([filter], opts);
+        let timeout = setTimeout(() => {
+          s.unsub();
+          resolve(null);
+        }, getTimeout);
+        s.on("event", (event) => {
+          s.unsub();
+          clearTimeout(timeout);
+          resolve(event);
+        });
+      }),
     publish(event) {
-      if (!event.id)
-        throw new Error(`event ${event} has no id`);
+      if (!event.id) throw new Error(`event ${event} has no id`);
       let id = event.id;
       trySend(["EVENT", event]);
       return {
         on: (type, cb) => {
           pubListeners[id] = pubListeners[id] || {
             ok: [],
-            failed: []
+            failed: [],
           };
           pubListeners[id][type].push(cb);
         },
         off: (type, cb) => {
           let listeners2 = pubListeners[id];
-          if (!listeners2)
-            return;
+          if (!listeners2) return;
           let idx = listeners2[type].indexOf(cb);
-          if (idx >= 0)
-            listeners2[type].splice(idx, 1);
-        }
+          if (idx >= 0) listeners2[type].splice(idx, 1);
+        },
       };
     },
     connect,
@@ -526,7 +520,7 @@ function relayInit(url, options = {}) {
     },
     get status() {
       return ws?.readyState ?? 3;
-    }
+    },
   };
 }
 
@@ -544,8 +538,7 @@ var SimplePool = class {
   close(relays) {
     relays.forEach((url) => {
       let relay = this._conn[normalizeURL(url)];
-      if (relay)
-        relay.close();
+      if (relay) relay.close();
     });
   }
   async ensureRelay(url) {
@@ -553,7 +546,7 @@ var SimplePool = class {
     if (!this._conn[nm]) {
       this._conn[nm] = relayInit(nm, {
         getTimeout: this.getTimeout * 0.9,
-        listTimeout: this.getTimeout * 0.9
+        listTimeout: this.getTimeout * 0.9,
       });
     }
     const relay = this._conn[nm];
@@ -562,7 +555,7 @@ var SimplePool = class {
   }
   sub(relays, filters, opts) {
     let _knownIds = /* @__PURE__ */ new Set();
-    let modifiedOpts = { ...opts || {} };
+    let modifiedOpts = { ...(opts || {}) };
     modifiedOpts.alreadyHaveEvent = (id, url) => {
       if (opts?.alreadyHaveEvent?.(id, url)) {
         return true;
@@ -579,8 +572,7 @@ var SimplePool = class {
     let eoseSent = false;
     let eoseTimeout = setTimeout(() => {
       eoseSent = true;
-      for (let cb of eoseListeners.values())
-        cb();
+      for (let cb of eoseListeners.values()) cb();
     }, this.eoseSubTimeout);
     relays.forEach(async (relay) => {
       let r;
@@ -590,17 +582,14 @@ var SimplePool = class {
         handleEose();
         return;
       }
-      if (!r)
-        return;
+      if (!r) return;
       let s = r.sub(filters, modifiedOpts);
       s.on("event", (event) => {
         _knownIds.add(event.id);
-        for (let cb of eventListeners.values())
-          cb(event);
+        for (let cb of eventListeners.values()) cb(event);
       });
       s.on("eose", () => {
-        if (eoseSent)
-          return;
+        if (eoseSent) return;
         handleEose();
       });
       subs.push(s);
@@ -608,8 +597,7 @@ var SimplePool = class {
         eosesMissing--;
         if (eosesMissing === 0) {
           clearTimeout(eoseTimeout);
-          for (let cb of eoseListeners.values())
-            cb();
+          for (let cb of eoseListeners.values()) cb();
         }
       }
     });
@@ -631,9 +619,8 @@ var SimplePool = class {
       off(type, cb) {
         if (type === "event") {
           eventListeners.delete(cb);
-        } else if (type === "eose")
-          eoseListeners.delete(cb);
-      }
+        } else if (type === "eose") eoseListeners.delete(cb);
+      },
     };
     return greaterSub;
   }
@@ -671,9 +658,7 @@ var SimplePool = class {
         r = await this.ensureRelay(relay);
         return r.publish(event);
       } catch (_) {
-        return { on() {
-        }, off() {
-        } };
+        return { on() {}, off() {} };
       }
     });
     const callbackMap = /* @__PURE__ */ new Map();
@@ -694,7 +679,7 @@ var SimplePool = class {
             pub.off(type, callback);
           }
         });
-      }
+      },
     };
   }
   seenOn(id) {
@@ -711,7 +696,7 @@ __export(nip19_exports, {
   noteEncode: () => noteEncode,
   nprofileEncode: () => nprofileEncode,
   npubEncode: () => npubEncode,
-  nsecEncode: () => nsecEncode
+  nsecEncode: () => nsecEncode,
 });
 import * as secp256k13 from "@noble/secp256k1";
 import { bech32 } from "@scure/base";
@@ -722,24 +707,20 @@ function decode(nip19) {
   switch (prefix) {
     case "nprofile": {
       let tlv = parseTLV(data);
-      if (!tlv[0]?.[0])
-        throw new Error("missing TLV 0 for nprofile");
-      if (tlv[0][0].length !== 32)
-        throw new Error("TLV 0 should be 32 bytes");
+      if (!tlv[0]?.[0]) throw new Error("missing TLV 0 for nprofile");
+      if (tlv[0][0].length !== 32) throw new Error("TLV 0 should be 32 bytes");
       return {
         type: "nprofile",
         data: {
           pubkey: secp256k13.utils.bytesToHex(tlv[0][0]),
-          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
-        }
+          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
+        },
       };
     }
     case "nevent": {
       let tlv = parseTLV(data);
-      if (!tlv[0]?.[0])
-        throw new Error("missing TLV 0 for nevent");
-      if (tlv[0][0].length !== 32)
-        throw new Error("TLV 0 should be 32 bytes");
+      if (!tlv[0]?.[0]) throw new Error("missing TLV 0 for nevent");
+      if (tlv[0][0].length !== 32) throw new Error("TLV 0 should be 32 bytes");
       if (tlv[2] && tlv[2][0].length !== 32)
         throw new Error("TLV 2 should be 32 bytes");
       return {
@@ -747,30 +728,25 @@ function decode(nip19) {
         data: {
           id: secp256k13.utils.bytesToHex(tlv[0][0]),
           relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
-          author: tlv[2]?.[0] ? secp256k13.utils.bytesToHex(tlv[2][0]) : void 0
-        }
+          author: tlv[2]?.[0] ? secp256k13.utils.bytesToHex(tlv[2][0]) : void 0,
+        },
       };
     }
     case "naddr": {
       let tlv = parseTLV(data);
-      if (!tlv[0]?.[0])
-        throw new Error("missing TLV 0 for naddr");
-      if (!tlv[2]?.[0])
-        throw new Error("missing TLV 2 for naddr");
-      if (tlv[2][0].length !== 32)
-        throw new Error("TLV 2 should be 32 bytes");
-      if (!tlv[3]?.[0])
-        throw new Error("missing TLV 3 for naddr");
-      if (tlv[3][0].length !== 4)
-        throw new Error("TLV 3 should be 4 bytes");
+      if (!tlv[0]?.[0]) throw new Error("missing TLV 0 for naddr");
+      if (!tlv[2]?.[0]) throw new Error("missing TLV 2 for naddr");
+      if (tlv[2][0].length !== 32) throw new Error("TLV 2 should be 32 bytes");
+      if (!tlv[3]?.[0]) throw new Error("missing TLV 3 for naddr");
+      if (tlv[3][0].length !== 4) throw new Error("TLV 3 should be 4 bytes");
       return {
         type: "naddr",
         data: {
           identifier: utf8Decoder.decode(tlv[0][0]),
           pubkey: secp256k13.utils.bytesToHex(tlv[2][0]),
           kind: parseInt(secp256k13.utils.bytesToHex(tlv[3][0]), 16),
-          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
-        }
+          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
+        },
       };
     }
     case "nsec":
@@ -789,8 +765,7 @@ function parseTLV(data) {
     let l = rest[1];
     let v = rest.slice(2, 2 + l);
     rest = rest.slice(2 + l);
-    if (v.length < l)
-      continue;
+    if (v.length < l) continue;
     result[t] = result[t] || [];
     result[t].push(v);
   }
@@ -813,7 +788,7 @@ function encodeBytes(prefix, hex) {
 function nprofileEncode(profile) {
   let data = encodeTLV({
     0: [secp256k13.utils.hexToBytes(profile.pubkey)],
-    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))
+    1: (profile.relays || []).map((url) => utf8Encoder.encode(url)),
   });
   let words = bech32.toWords(data);
   return bech32.encode("nprofile", words, Bech32MaxSize);
@@ -822,7 +797,7 @@ function neventEncode(event) {
   let data = encodeTLV({
     0: [secp256k13.utils.hexToBytes(event.id)],
     1: (event.relays || []).map((url) => utf8Encoder.encode(url)),
-    2: event.author ? [secp256k13.utils.hexToBytes(event.author)] : []
+    2: event.author ? [secp256k13.utils.hexToBytes(event.author)] : [],
   });
   let words = bech32.toWords(data);
   return bech32.encode("nevent", words, Bech32MaxSize);
@@ -834,7 +809,7 @@ function naddrEncode(addr) {
     0: [utf8Encoder.encode(addr.identifier)],
     1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),
     2: [secp256k13.utils.hexToBytes(addr.pubkey)],
-    3: [new Uint8Array(kind)]
+    3: [new Uint8Array(kind)],
   });
   let words = bech32.toWords(data);
   return bech32.encode("naddr", words, Bech32MaxSize);
@@ -854,7 +829,8 @@ function encodeTLV(tlv) {
 }
 
 // references.ts
-var mentionRegex = /\bnostr:((note|npub|naddr|nevent|nprofile)1\w+)\b|#\[(\d+)\]/g;
+var mentionRegex =
+  /\bnostr:((note|npub|naddr|nevent|nprofile)1\w+)\b|#\[(\d+)\]/g;
 function parseReferences(evt) {
   let references = [];
   for (let ref of evt.content.matchAll(mentionRegex)) {
@@ -865,58 +841,56 @@ function parseReferences(evt) {
           case "npub": {
             references.push({
               text: ref[0],
-              profile: { pubkey: data, relays: [] }
+              profile: { pubkey: data, relays: [] },
             });
             break;
           }
           case "nprofile": {
             references.push({
               text: ref[0],
-              profile: data
+              profile: data,
             });
             break;
           }
           case "note": {
             references.push({
               text: ref[0],
-              event: { id: data, relays: [] }
+              event: { id: data, relays: [] },
             });
             break;
           }
           case "nevent": {
             references.push({
               text: ref[0],
-              event: data
+              event: data,
             });
             break;
           }
           case "naddr": {
             references.push({
               text: ref[0],
-              address: data
+              address: data,
             });
             break;
           }
         }
-      } catch (err) {
-      }
+      } catch (err) {}
     } else if (ref[3]) {
       let idx = parseInt(ref[3], 10);
       let tag = evt.tags[idx];
-      if (!tag)
-        continue;
+      if (!tag) continue;
       switch (tag[0]) {
         case "p": {
           references.push({
             text: ref[0],
-            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }
+            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] },
           });
           break;
         }
         case "e": {
           references.push({
             text: ref[0],
-            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }
+            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] },
           });
           break;
         }
@@ -929,11 +903,10 @@ function parseReferences(evt) {
                 identifier,
                 pubkey,
                 kind: parseInt(kind, 10),
-                relays: tag[2] ? [tag[2]] : []
-              }
+                relays: tag[2] ? [tag[2]] : [],
+              },
             });
-          } catch (err) {
-          }
+          } catch (err) {}
           break;
         }
       }
@@ -946,7 +919,7 @@ function parseReferences(evt) {
 var nip04_exports = {};
 __export(nip04_exports, {
   decrypt: () => decrypt,
-  encrypt: () => encrypt
+  encrypt: () => encrypt,
 });
 import { randomBytes } from "@noble/hashes/utils";
 import * as secp256k14 from "@noble/secp256k1";
@@ -1002,19 +975,20 @@ var nip05_exports = {};
 __export(nip05_exports, {
   queryProfile: () => queryProfile,
   searchDomain: () => searchDomain,
-  useFetchImplementation: () => useFetchImplementation
+  useFetchImplementation: () => useFetchImplementation,
 });
 var _fetch;
 try {
   _fetch = fetch;
-} catch {
-}
+} catch {}
 function useFetchImplementation(fetchImplementation) {
   _fetch = fetchImplementation;
 }
 async function searchDomain(domain, query = "") {
   try {
-    let res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${query}`)).json();
+    let res = await (
+      await _fetch(`https://${domain}/.well-known/nostr.json?name=${query}`)
+    ).json();
     return res.names;
   } catch (_) {
     return {};
@@ -1026,23 +1000,22 @@ async function queryProfile(fullname) {
     domain = name;
     name = "_";
   }
-  if (!name.match(/^[A-Za-z0-9-_]+$/))
-    return null;
-  if (!domain.includes("."))
-    return null;
+  if (!name.match(/^[A-Za-z0-9-_]+$/)) return null;
+  if (!domain.includes(".")) return null;
   let res;
   try {
-    res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`)).json();
+    res = await (
+      await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`)
+    ).json();
   } catch (err) {
     return null;
   }
-  if (!res?.names?.[name])
-    return null;
+  if (!res?.names?.[name]) return null;
   let pubkey = res.names[name];
   let relays = res.relays?.[pubkey] || [];
   return {
     pubkey,
-    relays
+    relays,
   };
 }
 
@@ -1051,21 +1024,20 @@ var nip06_exports = {};
 __export(nip06_exports, {
   generateSeedWords: () => generateSeedWords,
   privateKeyFromSeedWords: () => privateKeyFromSeedWords,
-  validateWords: () => validateWords
+  validateWords: () => validateWords,
 });
 import * as secp256k15 from "@noble/secp256k1";
 import { wordlist } from "@scure/bip39/wordlists/english.js";
 import {
   generateMnemonic,
   mnemonicToSeedSync,
-  validateMnemonic
+  validateMnemonic,
 } from "@scure/bip39";
 import { HDKey } from "@scure/bip32";
 function privateKeyFromSeedWords(mnemonic, passphrase) {
   let root = HDKey.fromMasterSeed(mnemonicToSeedSync(mnemonic, passphrase));
   let privateKey = root.derive(`m/44'/1237'/0'/0/0`).privateKey;
-  if (!privateKey)
-    throw new Error("could not derive private key");
+  if (!privateKey) throw new Error("could not derive private key");
   return secp256k15.utils.bytesToHex(privateKey);
 }
 function generateSeedWords() {
@@ -1078,14 +1050,14 @@ function validateWords(words) {
 // nip10.ts
 var nip10_exports = {};
 __export(nip10_exports, {
-  parse: () => parse
+  parse: () => parse,
 });
 function parse(event) {
   const result = {
     reply: void 0,
     root: void 0,
     mentions: [],
-    profiles: []
+    profiles: [],
   };
   const eTags = [];
   for (const tag of event.tags) {
@@ -1095,7 +1067,7 @@ function parse(event) {
     if (tag[0] === "p" && tag[1]) {
       result.profiles.push({
         pubkey: tag[1],
-        relays: tag[2] ? [tag[2]] : []
+        relays: tag[2] ? [tag[2]] : [],
       });
     }
   }
@@ -1104,7 +1076,7 @@ function parse(event) {
     const [_, eTagEventId, eTagRelayUrl, eTagMarker] = eTag;
     const eventPointer = {
       id: eTagEventId,
-      relays: eTagRelayUrl ? [eTagRelayUrl] : []
+      relays: eTagRelayUrl ? [eTagRelayUrl] : [],
     };
     const isFirstETag = eTagIndex === 0;
     const isLastETag = eTagIndex === eTags.length - 1;
@@ -1137,18 +1109,15 @@ function parse(event) {
 var nip26_exports = {};
 __export(nip26_exports, {
   createDelegation: () => createDelegation,
-  getDelegator: () => getDelegator
+  getDelegator: () => getDelegator,
 });
 import * as secp256k16 from "@noble/secp256k1";
 import { sha256 as sha2562 } from "@noble/hashes/sha256";
 function createDelegation(privateKey, parameters) {
   let conditions = [];
-  if ((parameters.kind || -1) >= 0)
-    conditions.push(`kind=${parameters.kind}`);
-  if (parameters.until)
-    conditions.push(`created_at<${parameters.until}`);
-  if (parameters.since)
-    conditions.push(`created_at>${parameters.since}`);
+  if ((parameters.kind || -1) >= 0) conditions.push(`kind=${parameters.kind}`);
+  if (parameters.until) conditions.push(`created_at<${parameters.until}`);
+  if (parameters.since) conditions.push(`created_at>${parameters.since}`);
   let cond = conditions.join("&");
   if (cond === "")
     throw new Error("refusing to create a delegation without any conditions");
@@ -1162,13 +1131,14 @@ function createDelegation(privateKey, parameters) {
     from: getPublicKey(privateKey),
     to: parameters.pubkey,
     cond,
-    sig
+    sig,
   };
 }
 function getDelegator(event) {
-  let tag = event.tags.find((tag2) => tag2[0] === "delegation" && tag2.length >= 4);
-  if (!tag)
-    return null;
+  let tag = event.tags.find(
+    (tag2) => tag2[0] === "delegation" && tag2.length >= 4
+  );
+  if (!tag) return null;
   let pubkey = tag[1];
   let cond = tag[2];
   let sig = tag[3];
@@ -1177,18 +1147,24 @@ function getDelegator(event) {
     let [key, operator, value] = conditions[i].split(/\b/);
     if (key === "kind" && operator === "=" && event.kind === parseInt(value))
       continue;
-    else if (key === "created_at" && operator === "<" && event.created_at < parseInt(value))
+    else if (
+      key === "created_at" &&
+      operator === "<" &&
+      event.created_at < parseInt(value)
+    )
       continue;
-    else if (key === "created_at" && operator === ">" && event.created_at > parseInt(value))
+    else if (
+      key === "created_at" &&
+      operator === ">" &&
+      event.created_at > parseInt(value)
+    )
       continue;
-    else
-      return null;
+    else return null;
   }
   let sighash = sha2562(
     utf8Encoder.encode(`nostr:delegation:${event.pubkey}:${cond}`)
   );
-  if (!secp256k16.schnorr.verifySync(sig, sighash, pubkey))
-    return null;
+  if (!secp256k16.schnorr.verifySync(sig, sighash, pubkey)) return null;
   return pubkey;
 }
 
@@ -1196,20 +1172,24 @@ function getDelegator(event) {
 var nip39_exports = {};
 __export(nip39_exports, {
   useFetchImplementation: () => useFetchImplementation2,
-  validateGithub: () => validateGithub
+  validateGithub: () => validateGithub,
 });
 var _fetch2;
 try {
   _fetch2 = fetch;
-} catch {
-}
+} catch {}
 function useFetchImplementation2(fetchImplementation) {
   _fetch2 = fetchImplementation;
 }
 async function validateGithub(pubkey, username, proof) {
   try {
-    let res = await (await _fetch2(`https://gist.github.com/${username}/${proof}/raw`)).text();
-    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;
+    let res = await (
+      await _fetch2(`https://gist.github.com/${username}/${proof}/raw`)
+    ).text();
+    return (
+      res ===
+      `Verifying that I control the following Nostr public key: ${pubkey}`
+    );
   } catch (_) {
     return false;
   }
@@ -1222,14 +1202,13 @@ __export(nip57_exports, {
   makeZapReceipt: () => makeZapReceipt,
   makeZapRequest: () => makeZapRequest,
   useFetchImplementation: () => useFetchImplementation3,
-  validateZapRequest: () => validateZapRequest
+  validateZapRequest: () => validateZapRequest,
 });
 import { bech32 as bech322 } from "@scure/base";
 var _fetch3;
 try {
   _fetch3 = fetch;
-} catch {
-}
+} catch {}
 function useFetchImplementation3(fetchImplementation) {
   _fetch3 = fetchImplementation;
 }
@@ -1252,21 +1231,12 @@ async function getZapEndpoint(metadata) {
     if (body.allowsNostr && body.nostrPubkey) {
       return body.callback;
     }
-  } catch (err) {
-  }
+  } catch (err) {}
   return null;
 }
-function makeZapRequest({
-  profile,
-  event,
-  amount,
-  relays,
-  comment = ""
-}) {
-  if (!amount)
-    throw new Error("amount not given");
-  if (!profile)
-    throw new Error("profile not given");
+function makeZapRequest({ profile, event, amount, relays, comment = "" }) {
+  if (!amount) throw new Error("amount not given");
+  if (!profile) throw new Error("profile not given");
   let zr = {
     kind: 9734,
     created_at: Math.round(Date.now() / 1e3),
@@ -1274,8 +1244,8 @@ function makeZapRequest({
     tags: [
       ["p", profile],
       ["amount", amount.toString()],
-      ["relays", ...relays]
-    ]
+      ["relays", ...relays],
+    ],
   };
   if (event) {
     zr.tags.push(["e", event]);
@@ -1291,27 +1261,19 @@ function validateZapRequest(zapRequestString) {
   }
   if (!validateEvent(zapRequest))
     return "Zap request is not a valid Nostr event.";
-  if (!verifySignature(zapRequest))
-    return "Invalid signature on zap request.";
+  if (!verifySignature(zapRequest)) return "Invalid signature on zap request.";
   let p = zapRequest.tags.find(([t, v]) => t === "p" && v);
-  if (!p)
-    return "Zap request doesn't have a 'p' tag.";
+  if (!p) return "Zap request doesn't have a 'p' tag.";
   if (!p[1].match(/^[a-f0-9]{64}$/))
     return "Zap request 'p' tag is not valid hex.";
   let e = zapRequest.tags.find(([t, v]) => t === "e" && v);
   if (e && !e[1].match(/^[a-f0-9]{64}$/))
     return "Zap request 'e' tag is not valid hex.";
   let relays = zapRequest.tags.find(([t, v]) => t === "relays" && v);
-  if (!relays)
-    return "Zap request doesn't have a 'relays' tag.";
+  if (!relays) return "Zap request doesn't have a 'relays' tag.";
   return null;
 }
-function makeZapReceipt({
-  zapRequest,
-  preimage,
-  bolt11,
-  paidAt
-}) {
+function makeZapReceipt({ zapRequest, preimage, bolt11, paidAt }) {
   let zr = JSON.parse(zapRequest);
   let tagsFromZapRequest = zr.tags.filter(
     ([t]) => t === "e" || t === "p" || t === "a"
@@ -1323,8 +1285,8 @@ function makeZapReceipt({
     tags: [
       ...tagsFromZapRequest,
       ["bolt11", bolt11],
-      ["description", zapRequest]
-    ]
+      ["description", zapRequest],
+    ],
   };
   if (preimage) {
     zap.tags.push(["preimage", preimage]);
@@ -1336,8 +1298,10 @@ function makeZapReceipt({
 import * as secp256k17 from "@noble/secp256k1";
 import { hmac } from "@noble/hashes/hmac";
 import { sha256 as sha2563 } from "@noble/hashes/sha256";
-secp256k17.utils.hmacSha256Sync = (key, ...msgs) => hmac(sha2563, key, secp256k17.utils.concatBytes(...msgs));
-secp256k17.utils.sha256Sync = (...msgs) => sha2563(secp256k17.utils.concatBytes(...msgs));
+secp256k17.utils.hmacSha256Sync = (key, ...msgs) =>
+  hmac(sha2563, key, secp256k17.utils.concatBytes(...msgs));
+secp256k17.utils.sha256Sync = (...msgs) =>
+  sha2563(secp256k17.utils.concatBytes(...msgs));
 export {
   Kind,
   SimplePool,
@@ -1363,5 +1327,5 @@ export {
   signEvent,
   utils_exports as utils,
   validateEvent,
-  verifySignature
+  verifySignature,
 };
diff --git a/node_modules/nostr-tools/lib/nostr.cjs.js b/node_modules/nostr-tools/lib/nostr.cjs.js
index a1fef6a..4e58731 100644
--- a/node_modules/nostr-tools/lib/nostr.cjs.js
+++ b/node_modules/nostr-tools/lib/nostr.cjs.js
@@ -1,4 +1,5 @@
 "use strict";
+var { TextDecoder, TextEncoder } = require("text-encoding");
 var __create = Object.create;
 var __defProp = Object.defineProperty;
 var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
@@ -10,18 +11,27 @@ var __export = (target, all) => {
     __defProp(target, name, { get: all[name], enumerable: true });
 };
 var __copyProps = (to, from, except, desc) => {
-  if (from && typeof from === "object" || typeof from === "function") {
+  if ((from && typeof from === "object") || typeof from === "function") {
     for (let key of __getOwnPropNames(from))
       if (!__hasOwnProp.call(to, key) && key !== except)
-        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+        __defProp(to, key, {
+          get: () => from[key],
+          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
+        });
   }
   return to;
 };
-var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
-  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
-  mod
-));
-var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
+var __toESM = (mod, isNodeMode, target) => (
+  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
+  __copyProps(
+    isNodeMode || !mod || !mod.__esModule
+      ? __defProp(target, "default", { value: mod, enumerable: true })
+      : target,
+    mod
+  )
+);
+var __toCommonJS = (mod) =>
+  __copyProps(__defProp({}, "__esModule", { value: true }), mod);
 
 // index.ts
 var nostr_tools_exports = {};
@@ -50,7 +60,7 @@ __export(nostr_tools_exports, {
   signEvent: () => signEvent,
   utils: () => utils_exports,
   validateEvent: () => validateEvent,
-  verifySignature: () => verifySignature
+  verifySignature: () => verifySignature,
 });
 module.exports = __toCommonJS(nostr_tools_exports);
 
@@ -74,16 +84,18 @@ __export(utils_exports, {
   insertEventIntoDescendingList: () => insertEventIntoDescendingList,
   normalizeURL: () => normalizeURL,
   utf8Decoder: () => utf8Decoder,
-  utf8Encoder: () => utf8Encoder
+  utf8Encoder: () => utf8Encoder,
 });
 var utf8Decoder = new TextDecoder("utf-8");
 var utf8Encoder = new TextEncoder();
 function normalizeURL(url) {
   let p = new URL(url);
   p.pathname = p.pathname.replace(/\/+/g, "/");
-  if (p.pathname.endsWith("/"))
-    p.pathname = p.pathname.slice(0, -1);
-  if (p.port === "80" && p.protocol === "ws:" || p.port === "443" && p.protocol === "wss:")
+  if (p.pathname.endsWith("/")) p.pathname = p.pathname.slice(0, -1);
+  if (
+    (p.port === "80" && p.protocol === "ws:") ||
+    (p.port === "443" && p.protocol === "wss:")
+  )
     p.port = "";
   p.searchParams.sort();
   p.hash = "";
@@ -120,7 +132,7 @@ function insertEventIntoDescendingList(sortedArray, event) {
     return [
       ...sortedArray.slice(0, position),
       event,
-      ...sortedArray.slice(position)
+      ...sortedArray.slice(position),
     ];
   }
   return sortedArray;
@@ -156,7 +168,7 @@ function insertEventIntoAscendingList(sortedArray, event) {
     return [
       ...sortedArray.slice(0, position),
       event,
-      ...sortedArray.slice(position)
+      ...sortedArray.slice(position),
     ];
   }
   return sortedArray;
@@ -164,24 +176,24 @@ function insertEventIntoAscendingList(sortedArray, event) {
 
 // event.ts
 var Kind = /* @__PURE__ */ ((Kind2) => {
-  Kind2[Kind2["Metadata"] = 0] = "Metadata";
-  Kind2[Kind2["Text"] = 1] = "Text";
-  Kind2[Kind2["RecommendRelay"] = 2] = "RecommendRelay";
-  Kind2[Kind2["Contacts"] = 3] = "Contacts";
-  Kind2[Kind2["EncryptedDirectMessage"] = 4] = "EncryptedDirectMessage";
-  Kind2[Kind2["EventDeletion"] = 5] = "EventDeletion";
-  Kind2[Kind2["Reaction"] = 7] = "Reaction";
-  Kind2[Kind2["ChannelCreation"] = 40] = "ChannelCreation";
-  Kind2[Kind2["ChannelMetadata"] = 41] = "ChannelMetadata";
-  Kind2[Kind2["ChannelMessage"] = 42] = "ChannelMessage";
-  Kind2[Kind2["ChannelHideMessage"] = 43] = "ChannelHideMessage";
-  Kind2[Kind2["ChannelMuteUser"] = 44] = "ChannelMuteUser";
-  Kind2[Kind2["Report"] = 1984] = "Report";
-  Kind2[Kind2["ZapRequest"] = 9734] = "ZapRequest";
-  Kind2[Kind2["Zap"] = 9735] = "Zap";
-  Kind2[Kind2["RelayList"] = 10002] = "RelayList";
-  Kind2[Kind2["ClientAuth"] = 22242] = "ClientAuth";
-  Kind2[Kind2["Article"] = 30023] = "Article";
+  Kind2[(Kind2["Metadata"] = 0)] = "Metadata";
+  Kind2[(Kind2["Text"] = 1)] = "Text";
+  Kind2[(Kind2["RecommendRelay"] = 2)] = "RecommendRelay";
+  Kind2[(Kind2["Contacts"] = 3)] = "Contacts";
+  Kind2[(Kind2["EncryptedDirectMessage"] = 4)] = "EncryptedDirectMessage";
+  Kind2[(Kind2["EventDeletion"] = 5)] = "EventDeletion";
+  Kind2[(Kind2["Reaction"] = 7)] = "Reaction";
+  Kind2[(Kind2["ChannelCreation"] = 40)] = "ChannelCreation";
+  Kind2[(Kind2["ChannelMetadata"] = 41)] = "ChannelMetadata";
+  Kind2[(Kind2["ChannelMessage"] = 42)] = "ChannelMessage";
+  Kind2[(Kind2["ChannelHideMessage"] = 43)] = "ChannelHideMessage";
+  Kind2[(Kind2["ChannelMuteUser"] = 44)] = "ChannelMuteUser";
+  Kind2[(Kind2["Report"] = 1984)] = "Report";
+  Kind2[(Kind2["ZapRequest"] = 9734)] = "ZapRequest";
+  Kind2[(Kind2["Zap"] = 9735)] = "Zap";
+  Kind2[(Kind2["RelayList"] = 10002)] = "RelayList";
+  Kind2[(Kind2["ClientAuth"] = 22242)] = "ClientAuth";
+  Kind2[(Kind2["Article"] = 30023)] = "Article";
   return Kind2;
 })(Kind || {});
 function getBlankEvent() {
@@ -189,7 +201,7 @@ function getBlankEvent() {
     kind: 255,
     content: "",
     tags: [],
-    created_at: 0
+    created_at: 0,
   };
 }
 function finishEvent(t, privateKey) {
@@ -208,35 +220,28 @@ function serializeEvent(evt) {
     evt.created_at,
     evt.kind,
     evt.tags,
-    evt.content
+    evt.content,
   ]);
 }
 function getEventHash(event) {
-  let eventHash = (0, import_sha256.sha256)(utf8Encoder.encode(serializeEvent(event)));
+  let eventHash = (0, import_sha256.sha256)(
+    utf8Encoder.encode(serializeEvent(event))
+  );
   return secp256k12.utils.bytesToHex(eventHash);
 }
 function validateEvent(event) {
-  if (typeof event !== "object")
-    return false;
-  if (typeof event.kind !== "number")
-    return false;
-  if (typeof event.content !== "string")
-    return false;
-  if (typeof event.created_at !== "number")
-    return false;
-  if (typeof event.pubkey !== "string")
-    return false;
-  if (!event.pubkey.match(/^[a-f0-9]{64}$/))
-    return false;
-  if (!Array.isArray(event.tags))
-    return false;
+  if (typeof event !== "object") return false;
+  if (typeof event.kind !== "number") return false;
+  if (typeof event.content !== "string") return false;
+  if (typeof event.created_at !== "number") return false;
+  if (typeof event.pubkey !== "string") return false;
+  if (!event.pubkey.match(/^[a-f0-9]{64}$/)) return false;
+  if (!Array.isArray(event.tags)) return false;
   for (let i = 0; i < event.tags.length; i++) {
     let tag = event.tags[i];
-    if (!Array.isArray(tag))
-      return false;
+    if (!Array.isArray(tag)) return false;
     for (let j = 0; j < tag.length; j++) {
-      if (typeof tag[j] === "object")
-        return false;
+      if (typeof tag[j] === "object") return false;
     }
   }
   return true;
@@ -256,32 +261,30 @@ function signEvent(event, key) {
 
 // filter.ts
 function matchFilter(filter, event) {
-  if (filter.ids && filter.ids.indexOf(event.id) === -1)
-    return false;
-  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1)
-    return false;
+  if (filter.ids && filter.ids.indexOf(event.id) === -1) return false;
+  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) return false;
   if (filter.authors && filter.authors.indexOf(event.pubkey) === -1)
     return false;
   for (let f in filter) {
     if (f[0] === "#") {
       let tagName = f.slice(1);
       let values = filter[`#${tagName}`];
-      if (values && !event.tags.find(
-        ([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1
-      ))
+      if (
+        values &&
+        !event.tags.find(
+          ([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1
+        )
+      )
         return false;
     }
   }
-  if (filter.since && event.created_at < filter.since)
-    return false;
-  if (filter.until && event.created_at >= filter.until)
-    return false;
+  if (filter.since && event.created_at < filter.since) return false;
+  if (filter.until && event.created_at >= filter.until) return false;
   return true;
 }
 function matchFilters(filters, event) {
   for (let i = 0; i < filters.length; i++) {
-    if (matchFilter(filters[i], event))
-      return true;
+    if (matchFilter(filters[i], event)) return true;
   }
   return false;
 }
@@ -294,7 +297,7 @@ __export(fakejson_exports, {
   getSubscriptionId: () => getSubscriptionId,
   matchEventId: () => matchEventId,
   matchEventKind: () => matchEventKind,
-  matchEventPubkey: () => matchEventPubkey
+  matchEventPubkey: () => matchEventPubkey,
 });
 function getHex64(json, field) {
   let len = field.length + 3;
@@ -311,15 +314,12 @@ function getInt(json, field) {
 }
 function getSubscriptionId(json) {
   let idx = json.slice(0, 22).indexOf(`"EVENT"`);
-  if (idx === -1)
-    return null;
+  if (idx === -1) return null;
   let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
-  if (pstart === -1)
-    return null;
+  if (pstart === -1) return null;
   let start = idx + 7 + 1 + pstart;
   let pend = json.slice(start + 1, 80).indexOf(`"`);
-  if (pend === -1)
-    return null;
+  if (pend === -1) return null;
   let end = start + 1 + pend;
   return json.slice(start + 1, end);
 }
@@ -342,14 +342,13 @@ function relayInit(url, options = {}) {
     connect: [],
     disconnect: [],
     error: [],
-    notice: []
+    notice: [],
   };
   var subListeners = {};
   var pubListeners = {};
   var connectionPromise;
   async function connectRelay() {
-    if (connectionPromise)
-      return connectionPromise;
+    if (connectionPromise) return connectionPromise;
     connectionPromise = new Promise((resolve, reject) => {
       try {
         ws = new WebSocket(url);
@@ -384,12 +383,15 @@ function relayInit(url, options = {}) {
           return;
         }
         var json = incomingMessageQueue.shift();
-        if (!json)
-          return;
+        if (!json) return;
         let subid = getSubscriptionId(json);
         if (subid) {
           let so = openSubs[subid];
-          if (so && so.alreadyHaveEvent && so.alreadyHaveEvent(getHex64(json, "id"), url)) {
+          if (
+            so &&
+            so.alreadyHaveEvent &&
+            so.alreadyHaveEvent(getHex64(json, "id"), url)
+          ) {
             return;
           }
         }
@@ -399,7 +401,12 @@ function relayInit(url, options = {}) {
             case "EVENT":
               let id = data[1];
               let event = data[2];
-              if (validateEvent(event) && openSubs[id] && (openSubs[id].skipVerification || verifySignature(event)) && matchFilters(openSubs[id].filters, event)) {
+              if (
+                validateEvent(event) &&
+                openSubs[id] &&
+                (openSubs[id].skipVerification || verifySignature(event)) &&
+                matchFilters(openSubs[id].filters, event)
+              ) {
                 openSubs[id];
                 (subListeners[id]?.event || []).forEach((cb) => cb(event));
               }
@@ -417,10 +424,8 @@ function relayInit(url, options = {}) {
               let ok = data[2];
               let reason = data[3] || "";
               if (id2 in pubListeners) {
-                if (ok)
-                  pubListeners[id2].ok.forEach((cb) => cb());
-                else
-                  pubListeners[id2].failed.forEach((cb) => cb(reason));
+                if (ok) pubListeners[id2].ok.forEach((cb) => cb());
+                else pubListeners[id2].failed.forEach((cb) => cb(reason));
                 pubListeners[id2].ok = [];
                 pubListeners[id2].failed = [];
               }
@@ -442,8 +447,7 @@ function relayInit(url, options = {}) {
     return ws?.readyState === 1;
   }
   async function connect() {
-    if (connected())
-      return;
+    if (connected()) return;
     await connectRelay();
   }
   async function trySend(params) {
@@ -460,25 +464,29 @@ function relayInit(url, options = {}) {
       console.log(err);
     }
   }
-  const sub = (filters, {
-    skipVerification = false,
-    alreadyHaveEvent = null,
-    id = Math.random().toString().slice(2)
-  } = {}) => {
+  const sub = (
+    filters,
+    {
+      skipVerification = false,
+      alreadyHaveEvent = null,
+      id = Math.random().toString().slice(2),
+    } = {}
+  ) => {
     let subid = id;
     openSubs[subid] = {
       id: subid,
       filters,
       skipVerification,
-      alreadyHaveEvent
+      alreadyHaveEvent,
     };
     trySend(["REQ", subid, ...filters]);
     return {
-      sub: (newFilters, newOpts = {}) => sub(newFilters || filters, {
-        skipVerification: newOpts.skipVerification || skipVerification,
-        alreadyHaveEvent: newOpts.alreadyHaveEvent || alreadyHaveEvent,
-        id: subid
-      }),
+      sub: (newFilters, newOpts = {}) =>
+        sub(newFilters || filters, {
+          skipVerification: newOpts.skipVerification || skipVerification,
+          alreadyHaveEvent: newOpts.alreadyHaveEvent || alreadyHaveEvent,
+          id: subid,
+        }),
       unsub: () => {
         delete openSubs[subid];
         delete subListeners[subid];
@@ -487,16 +495,15 @@ function relayInit(url, options = {}) {
       on: (type, cb) => {
         subListeners[subid] = subListeners[subid] || {
           event: [],
-          eose: []
+          eose: [],
         };
         subListeners[subid][type].push(cb);
       },
       off: (type, cb) => {
         let listeners2 = subListeners[subid];
         let idx = listeners2[type].indexOf(cb);
-        if (idx >= 0)
-          listeners2[type].splice(idx, 1);
-      }
+        if (idx >= 0) listeners2[type].splice(idx, 1);
+      },
     };
   };
   return {
@@ -505,64 +512,61 @@ function relayInit(url, options = {}) {
     on: (type, cb) => {
       listeners[type].push(cb);
       if (type === "connect" && ws?.readyState === 1) {
-        ;
         cb();
       }
     },
     off: (type, cb) => {
       let index = listeners[type].indexOf(cb);
-      if (index !== -1)
-        listeners[type].splice(index, 1);
+      if (index !== -1) listeners[type].splice(index, 1);
     },
-    list: (filters, opts) => new Promise((resolve) => {
-      let s = sub(filters, opts);
-      let events = [];
-      let timeout = setTimeout(() => {
-        s.unsub();
-        resolve(events);
-      }, listTimeout);
-      s.on("eose", () => {
-        s.unsub();
-        clearTimeout(timeout);
-        resolve(events);
-      });
-      s.on("event", (event) => {
-        events.push(event);
-      });
-    }),
-    get: (filter, opts) => new Promise((resolve) => {
-      let s = sub([filter], opts);
-      let timeout = setTimeout(() => {
-        s.unsub();
-        resolve(null);
-      }, getTimeout);
-      s.on("event", (event) => {
-        s.unsub();
-        clearTimeout(timeout);
-        resolve(event);
-      });
-    }),
+    list: (filters, opts) =>
+      new Promise((resolve) => {
+        let s = sub(filters, opts);
+        let events = [];
+        let timeout = setTimeout(() => {
+          s.unsub();
+          resolve(events);
+        }, listTimeout);
+        s.on("eose", () => {
+          s.unsub();
+          clearTimeout(timeout);
+          resolve(events);
+        });
+        s.on("event", (event) => {
+          events.push(event);
+        });
+      }),
+    get: (filter, opts) =>
+      new Promise((resolve) => {
+        let s = sub([filter], opts);
+        let timeout = setTimeout(() => {
+          s.unsub();
+          resolve(null);
+        }, getTimeout);
+        s.on("event", (event) => {
+          s.unsub();
+          clearTimeout(timeout);
+          resolve(event);
+        });
+      }),
     publish(event) {
-      if (!event.id)
-        throw new Error(`event ${event} has no id`);
+      if (!event.id) throw new Error(`event ${event} has no id`);
       let id = event.id;
       trySend(["EVENT", event]);
       return {
         on: (type, cb) => {
           pubListeners[id] = pubListeners[id] || {
             ok: [],
-            failed: []
+            failed: [],
           };
           pubListeners[id][type].push(cb);
         },
         off: (type, cb) => {
           let listeners2 = pubListeners[id];
-          if (!listeners2)
-            return;
+          if (!listeners2) return;
           let idx = listeners2[type].indexOf(cb);
-          if (idx >= 0)
-            listeners2[type].splice(idx, 1);
-        }
+          if (idx >= 0) listeners2[type].splice(idx, 1);
+        },
       };
     },
     connect,
@@ -576,7 +580,7 @@ function relayInit(url, options = {}) {
     },
     get status() {
       return ws?.readyState ?? 3;
-    }
+    },
   };
 }
 
@@ -594,8 +598,7 @@ var SimplePool = class {
   close(relays) {
     relays.forEach((url) => {
       let relay = this._conn[normalizeURL(url)];
-      if (relay)
-        relay.close();
+      if (relay) relay.close();
     });
   }
   async ensureRelay(url) {
@@ -603,7 +606,7 @@ var SimplePool = class {
     if (!this._conn[nm]) {
       this._conn[nm] = relayInit(nm, {
         getTimeout: this.getTimeout * 0.9,
-        listTimeout: this.getTimeout * 0.9
+        listTimeout: this.getTimeout * 0.9,
       });
     }
     const relay = this._conn[nm];
@@ -612,7 +615,7 @@ var SimplePool = class {
   }
   sub(relays, filters, opts) {
     let _knownIds = /* @__PURE__ */ new Set();
-    let modifiedOpts = { ...opts || {} };
+    let modifiedOpts = { ...(opts || {}) };
     modifiedOpts.alreadyHaveEvent = (id, url) => {
       if (opts?.alreadyHaveEvent?.(id, url)) {
         return true;
@@ -629,8 +632,7 @@ var SimplePool = class {
     let eoseSent = false;
     let eoseTimeout = setTimeout(() => {
       eoseSent = true;
-      for (let cb of eoseListeners.values())
-        cb();
+      for (let cb of eoseListeners.values()) cb();
     }, this.eoseSubTimeout);
     relays.forEach(async (relay) => {
       let r;
@@ -640,17 +642,14 @@ var SimplePool = class {
         handleEose();
         return;
       }
-      if (!r)
-        return;
+      if (!r) return;
       let s = r.sub(filters, modifiedOpts);
       s.on("event", (event) => {
         _knownIds.add(event.id);
-        for (let cb of eventListeners.values())
-          cb(event);
+        for (let cb of eventListeners.values()) cb(event);
       });
       s.on("eose", () => {
-        if (eoseSent)
-          return;
+        if (eoseSent) return;
         handleEose();
       });
       subs.push(s);
@@ -658,8 +657,7 @@ var SimplePool = class {
         eosesMissing--;
         if (eosesMissing === 0) {
           clearTimeout(eoseTimeout);
-          for (let cb of eoseListeners.values())
-            cb();
+          for (let cb of eoseListeners.values()) cb();
         }
       }
     });
@@ -681,9 +679,8 @@ var SimplePool = class {
       off(type, cb) {
         if (type === "event") {
           eventListeners.delete(cb);
-        } else if (type === "eose")
-          eoseListeners.delete(cb);
-      }
+        } else if (type === "eose") eoseListeners.delete(cb);
+      },
     };
     return greaterSub;
   }
@@ -721,9 +718,7 @@ var SimplePool = class {
         r = await this.ensureRelay(relay);
         return r.publish(event);
       } catch (_) {
-        return { on() {
-        }, off() {
-        } };
+        return { on() {}, off() {} };
       }
     });
     const callbackMap = /* @__PURE__ */ new Map();
@@ -744,7 +739,7 @@ var SimplePool = class {
             pub.off(type, callback);
           }
         });
-      }
+      },
     };
   }
   seenOn(id) {
@@ -761,7 +756,7 @@ __export(nip19_exports, {
   noteEncode: () => noteEncode,
   nprofileEncode: () => nprofileEncode,
   npubEncode: () => npubEncode,
-  nsecEncode: () => nsecEncode
+  nsecEncode: () => nsecEncode,
 });
 var secp256k13 = __toESM(require("@noble/secp256k1"));
 var import_base = require("@scure/base");
@@ -772,24 +767,20 @@ function decode(nip19) {
   switch (prefix) {
     case "nprofile": {
       let tlv = parseTLV(data);
-      if (!tlv[0]?.[0])
-        throw new Error("missing TLV 0 for nprofile");
-      if (tlv[0][0].length !== 32)
-        throw new Error("TLV 0 should be 32 bytes");
+      if (!tlv[0]?.[0]) throw new Error("missing TLV 0 for nprofile");
+      if (tlv[0][0].length !== 32) throw new Error("TLV 0 should be 32 bytes");
       return {
         type: "nprofile",
         data: {
           pubkey: secp256k13.utils.bytesToHex(tlv[0][0]),
-          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
-        }
+          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
+        },
       };
     }
     case "nevent": {
       let tlv = parseTLV(data);
-      if (!tlv[0]?.[0])
-        throw new Error("missing TLV 0 for nevent");
-      if (tlv[0][0].length !== 32)
-        throw new Error("TLV 0 should be 32 bytes");
+      if (!tlv[0]?.[0]) throw new Error("missing TLV 0 for nevent");
+      if (tlv[0][0].length !== 32) throw new Error("TLV 0 should be 32 bytes");
       if (tlv[2] && tlv[2][0].length !== 32)
         throw new Error("TLV 2 should be 32 bytes");
       return {
@@ -797,30 +788,25 @@ function decode(nip19) {
         data: {
           id: secp256k13.utils.bytesToHex(tlv[0][0]),
           relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
-          author: tlv[2]?.[0] ? secp256k13.utils.bytesToHex(tlv[2][0]) : void 0
-        }
+          author: tlv[2]?.[0] ? secp256k13.utils.bytesToHex(tlv[2][0]) : void 0,
+        },
       };
     }
     case "naddr": {
       let tlv = parseTLV(data);
-      if (!tlv[0]?.[0])
-        throw new Error("missing TLV 0 for naddr");
-      if (!tlv[2]?.[0])
-        throw new Error("missing TLV 2 for naddr");
-      if (tlv[2][0].length !== 32)
-        throw new Error("TLV 2 should be 32 bytes");
-      if (!tlv[3]?.[0])
-        throw new Error("missing TLV 3 for naddr");
-      if (tlv[3][0].length !== 4)
-        throw new Error("TLV 3 should be 4 bytes");
+      if (!tlv[0]?.[0]) throw new Error("missing TLV 0 for naddr");
+      if (!tlv[2]?.[0]) throw new Error("missing TLV 2 for naddr");
+      if (tlv[2][0].length !== 32) throw new Error("TLV 2 should be 32 bytes");
+      if (!tlv[3]?.[0]) throw new Error("missing TLV 3 for naddr");
+      if (tlv[3][0].length !== 4) throw new Error("TLV 3 should be 4 bytes");
       return {
         type: "naddr",
         data: {
           identifier: utf8Decoder.decode(tlv[0][0]),
           pubkey: secp256k13.utils.bytesToHex(tlv[2][0]),
           kind: parseInt(secp256k13.utils.bytesToHex(tlv[3][0]), 16),
-          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
-        }
+          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
+        },
       };
     }
     case "nsec":
@@ -839,8 +825,7 @@ function parseTLV(data) {
     let l = rest[1];
     let v = rest.slice(2, 2 + l);
     rest = rest.slice(2 + l);
-    if (v.length < l)
-      continue;
+    if (v.length < l) continue;
     result[t] = result[t] || [];
     result[t].push(v);
   }
@@ -863,7 +848,7 @@ function encodeBytes(prefix, hex) {
 function nprofileEncode(profile) {
   let data = encodeTLV({
     0: [secp256k13.utils.hexToBytes(profile.pubkey)],
-    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))
+    1: (profile.relays || []).map((url) => utf8Encoder.encode(url)),
   });
   let words = import_base.bech32.toWords(data);
   return import_base.bech32.encode("nprofile", words, Bech32MaxSize);
@@ -872,7 +857,7 @@ function neventEncode(event) {
   let data = encodeTLV({
     0: [secp256k13.utils.hexToBytes(event.id)],
     1: (event.relays || []).map((url) => utf8Encoder.encode(url)),
-    2: event.author ? [secp256k13.utils.hexToBytes(event.author)] : []
+    2: event.author ? [secp256k13.utils.hexToBytes(event.author)] : [],
   });
   let words = import_base.bech32.toWords(data);
   return import_base.bech32.encode("nevent", words, Bech32MaxSize);
@@ -884,7 +869,7 @@ function naddrEncode(addr) {
     0: [utf8Encoder.encode(addr.identifier)],
     1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),
     2: [secp256k13.utils.hexToBytes(addr.pubkey)],
-    3: [new Uint8Array(kind)]
+    3: [new Uint8Array(kind)],
   });
   let words = import_base.bech32.toWords(data);
   return import_base.bech32.encode("naddr", words, Bech32MaxSize);
@@ -904,7 +889,8 @@ function encodeTLV(tlv) {
 }
 
 // references.ts
-var mentionRegex = /\bnostr:((note|npub|naddr|nevent|nprofile)1\w+)\b|#\[(\d+)\]/g;
+var mentionRegex =
+  /\bnostr:((note|npub|naddr|nevent|nprofile)1\w+)\b|#\[(\d+)\]/g;
 function parseReferences(evt) {
   let references = [];
   for (let ref of evt.content.matchAll(mentionRegex)) {
@@ -915,58 +901,56 @@ function parseReferences(evt) {
           case "npub": {
             references.push({
               text: ref[0],
-              profile: { pubkey: data, relays: [] }
+              profile: { pubkey: data, relays: [] },
             });
             break;
           }
           case "nprofile": {
             references.push({
               text: ref[0],
-              profile: data
+              profile: data,
             });
             break;
           }
           case "note": {
             references.push({
               text: ref[0],
-              event: { id: data, relays: [] }
+              event: { id: data, relays: [] },
             });
             break;
           }
           case "nevent": {
             references.push({
               text: ref[0],
-              event: data
+              event: data,
             });
             break;
           }
           case "naddr": {
             references.push({
               text: ref[0],
-              address: data
+              address: data,
             });
             break;
           }
         }
-      } catch (err) {
-      }
+      } catch (err) {}
     } else if (ref[3]) {
       let idx = parseInt(ref[3], 10);
       let tag = evt.tags[idx];
-      if (!tag)
-        continue;
+      if (!tag) continue;
       switch (tag[0]) {
         case "p": {
           references.push({
             text: ref[0],
-            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }
+            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] },
           });
           break;
         }
         case "e": {
           references.push({
             text: ref[0],
-            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }
+            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] },
           });
           break;
         }
@@ -979,11 +963,10 @@ function parseReferences(evt) {
                 identifier,
                 pubkey,
                 kind: parseInt(kind, 10),
-                relays: tag[2] ? [tag[2]] : []
-              }
+                relays: tag[2] ? [tag[2]] : [],
+              },
             });
-          } catch (err) {
-          }
+          } catch (err) {}
           break;
         }
       }
@@ -996,7 +979,7 @@ function parseReferences(evt) {
 var nip04_exports = {};
 __export(nip04_exports, {
   decrypt: () => decrypt,
-  encrypt: () => encrypt
+  encrypt: () => encrypt,
 });
 var import_utils4 = require("@noble/hashes/utils");
 var secp256k14 = __toESM(require("@noble/secp256k1"));
@@ -1052,19 +1035,20 @@ var nip05_exports = {};
 __export(nip05_exports, {
   queryProfile: () => queryProfile,
   searchDomain: () => searchDomain,
-  useFetchImplementation: () => useFetchImplementation
+  useFetchImplementation: () => useFetchImplementation,
 });
 var _fetch;
 try {
   _fetch = fetch;
-} catch {
-}
+} catch {}
 function useFetchImplementation(fetchImplementation) {
   _fetch = fetchImplementation;
 }
 async function searchDomain(domain, query = "") {
   try {
-    let res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${query}`)).json();
+    let res = await (
+      await _fetch(`https://${domain}/.well-known/nostr.json?name=${query}`)
+    ).json();
     return res.names;
   } catch (_) {
     return {};
@@ -1076,23 +1060,22 @@ async function queryProfile(fullname) {
     domain = name;
     name = "_";
   }
-  if (!name.match(/^[A-Za-z0-9-_]+$/))
-    return null;
-  if (!domain.includes("."))
-    return null;
+  if (!name.match(/^[A-Za-z0-9-_]+$/)) return null;
+  if (!domain.includes(".")) return null;
   let res;
   try {
-    res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`)).json();
+    res = await (
+      await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`)
+    ).json();
   } catch (err) {
     return null;
   }
-  if (!res?.names?.[name])
-    return null;
+  if (!res?.names?.[name]) return null;
   let pubkey = res.names[name];
   let relays = res.relays?.[pubkey] || [];
   return {
     pubkey,
-    relays
+    relays,
   };
 }
 
@@ -1101,17 +1084,18 @@ var nip06_exports = {};
 __export(nip06_exports, {
   generateSeedWords: () => generateSeedWords,
   privateKeyFromSeedWords: () => privateKeyFromSeedWords,
-  validateWords: () => validateWords
+  validateWords: () => validateWords,
 });
 var secp256k15 = __toESM(require("@noble/secp256k1"));
 var import_english = require("@scure/bip39/wordlists/english.js");
 var import_bip39 = require("@scure/bip39");
 var import_bip32 = require("@scure/bip32");
 function privateKeyFromSeedWords(mnemonic, passphrase) {
-  let root = import_bip32.HDKey.fromMasterSeed((0, import_bip39.mnemonicToSeedSync)(mnemonic, passphrase));
+  let root = import_bip32.HDKey.fromMasterSeed(
+    (0, import_bip39.mnemonicToSeedSync)(mnemonic, passphrase)
+  );
   let privateKey = root.derive(`m/44'/1237'/0'/0/0`).privateKey;
-  if (!privateKey)
-    throw new Error("could not derive private key");
+  if (!privateKey) throw new Error("could not derive private key");
   return secp256k15.utils.bytesToHex(privateKey);
 }
 function generateSeedWords() {
@@ -1124,14 +1108,14 @@ function validateWords(words) {
 // nip10.ts
 var nip10_exports = {};
 __export(nip10_exports, {
-  parse: () => parse
+  parse: () => parse,
 });
 function parse(event) {
   const result = {
     reply: void 0,
     root: void 0,
     mentions: [],
-    profiles: []
+    profiles: [],
   };
   const eTags = [];
   for (const tag of event.tags) {
@@ -1141,7 +1125,7 @@ function parse(event) {
     if (tag[0] === "p" && tag[1]) {
       result.profiles.push({
         pubkey: tag[1],
-        relays: tag[2] ? [tag[2]] : []
+        relays: tag[2] ? [tag[2]] : [],
       });
     }
   }
@@ -1150,7 +1134,7 @@ function parse(event) {
     const [_, eTagEventId, eTagRelayUrl, eTagMarker] = eTag;
     const eventPointer = {
       id: eTagEventId,
-      relays: eTagRelayUrl ? [eTagRelayUrl] : []
+      relays: eTagRelayUrl ? [eTagRelayUrl] : [],
     };
     const isFirstETag = eTagIndex === 0;
     const isLastETag = eTagIndex === eTags.length - 1;
@@ -1183,18 +1167,15 @@ function parse(event) {
 var nip26_exports = {};
 __export(nip26_exports, {
   createDelegation: () => createDelegation,
-  getDelegator: () => getDelegator
+  getDelegator: () => getDelegator,
 });
 var secp256k16 = __toESM(require("@noble/secp256k1"));
 var import_sha2562 = require("@noble/hashes/sha256");
 function createDelegation(privateKey, parameters) {
   let conditions = [];
-  if ((parameters.kind || -1) >= 0)
-    conditions.push(`kind=${parameters.kind}`);
-  if (parameters.until)
-    conditions.push(`created_at<${parameters.until}`);
-  if (parameters.since)
-    conditions.push(`created_at>${parameters.since}`);
+  if ((parameters.kind || -1) >= 0) conditions.push(`kind=${parameters.kind}`);
+  if (parameters.until) conditions.push(`created_at<${parameters.until}`);
+  if (parameters.since) conditions.push(`created_at>${parameters.since}`);
   let cond = conditions.join("&");
   if (cond === "")
     throw new Error("refusing to create a delegation without any conditions");
@@ -1208,13 +1189,14 @@ function createDelegation(privateKey, parameters) {
     from: getPublicKey(privateKey),
     to: parameters.pubkey,
     cond,
-    sig
+    sig,
   };
 }
 function getDelegator(event) {
-  let tag = event.tags.find((tag2) => tag2[0] === "delegation" && tag2.length >= 4);
-  if (!tag)
-    return null;
+  let tag = event.tags.find(
+    (tag2) => tag2[0] === "delegation" && tag2.length >= 4
+  );
+  if (!tag) return null;
   let pubkey = tag[1];
   let cond = tag[2];
   let sig = tag[3];
@@ -1223,18 +1205,24 @@ function getDelegator(event) {
     let [key, operator, value] = conditions[i].split(/\b/);
     if (key === "kind" && operator === "=" && event.kind === parseInt(value))
       continue;
-    else if (key === "created_at" && operator === "<" && event.created_at < parseInt(value))
+    else if (
+      key === "created_at" &&
+      operator === "<" &&
+      event.created_at < parseInt(value)
+    )
       continue;
-    else if (key === "created_at" && operator === ">" && event.created_at > parseInt(value))
+    else if (
+      key === "created_at" &&
+      operator === ">" &&
+      event.created_at > parseInt(value)
+    )
       continue;
-    else
-      return null;
+    else return null;
   }
   let sighash = (0, import_sha2562.sha256)(
     utf8Encoder.encode(`nostr:delegation:${event.pubkey}:${cond}`)
   );
-  if (!secp256k16.schnorr.verifySync(sig, sighash, pubkey))
-    return null;
+  if (!secp256k16.schnorr.verifySync(sig, sighash, pubkey)) return null;
   return pubkey;
 }
 
@@ -1242,20 +1230,24 @@ function getDelegator(event) {
 var nip39_exports = {};
 __export(nip39_exports, {
   useFetchImplementation: () => useFetchImplementation2,
-  validateGithub: () => validateGithub
+  validateGithub: () => validateGithub,
 });
 var _fetch2;
 try {
   _fetch2 = fetch;
-} catch {
-}
+} catch {}
 function useFetchImplementation2(fetchImplementation) {
   _fetch2 = fetchImplementation;
 }
 async function validateGithub(pubkey, username, proof) {
   try {
-    let res = await (await _fetch2(`https://gist.github.com/${username}/${proof}/raw`)).text();
-    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;
+    let res = await (
+      await _fetch2(`https://gist.github.com/${username}/${proof}/raw`)
+    ).text();
+    return (
+      res ===
+      `Verifying that I control the following Nostr public key: ${pubkey}`
+    );
   } catch (_) {
     return false;
   }
@@ -1268,14 +1260,13 @@ __export(nip57_exports, {
   makeZapReceipt: () => makeZapReceipt,
   makeZapRequest: () => makeZapRequest,
   useFetchImplementation: () => useFetchImplementation3,
-  validateZapRequest: () => validateZapRequest
+  validateZapRequest: () => validateZapRequest,
 });
 var import_base3 = require("@scure/base");
 var _fetch3;
 try {
   _fetch3 = fetch;
-} catch {
-}
+} catch {}
 function useFetchImplementation3(fetchImplementation) {
   _fetch3 = fetchImplementation;
 }
@@ -1298,21 +1289,12 @@ async function getZapEndpoint(metadata) {
     if (body.allowsNostr && body.nostrPubkey) {
       return body.callback;
     }
-  } catch (err) {
-  }
+  } catch (err) {}
   return null;
 }
-function makeZapRequest({
-  profile,
-  event,
-  amount,
-  relays,
-  comment = ""
-}) {
-  if (!amount)
-    throw new Error("amount not given");
-  if (!profile)
-    throw new Error("profile not given");
+function makeZapRequest({ profile, event, amount, relays, comment = "" }) {
+  if (!amount) throw new Error("amount not given");
+  if (!profile) throw new Error("profile not given");
   let zr = {
     kind: 9734,
     created_at: Math.round(Date.now() / 1e3),
@@ -1320,8 +1302,8 @@ function makeZapRequest({
     tags: [
       ["p", profile],
       ["amount", amount.toString()],
-      ["relays", ...relays]
-    ]
+      ["relays", ...relays],
+    ],
   };
   if (event) {
     zr.tags.push(["e", event]);
@@ -1337,27 +1319,19 @@ function validateZapRequest(zapRequestString) {
   }
   if (!validateEvent(zapRequest))
     return "Zap request is not a valid Nostr event.";
-  if (!verifySignature(zapRequest))
-    return "Invalid signature on zap request.";
+  if (!verifySignature(zapRequest)) return "Invalid signature on zap request.";
   let p = zapRequest.tags.find(([t, v]) => t === "p" && v);
-  if (!p)
-    return "Zap request doesn't have a 'p' tag.";
+  if (!p) return "Zap request doesn't have a 'p' tag.";
   if (!p[1].match(/^[a-f0-9]{64}$/))
     return "Zap request 'p' tag is not valid hex.";
   let e = zapRequest.tags.find(([t, v]) => t === "e" && v);
   if (e && !e[1].match(/^[a-f0-9]{64}$/))
     return "Zap request 'e' tag is not valid hex.";
   let relays = zapRequest.tags.find(([t, v]) => t === "relays" && v);
-  if (!relays)
-    return "Zap request doesn't have a 'relays' tag.";
+  if (!relays) return "Zap request doesn't have a 'relays' tag.";
   return null;
 }
-function makeZapReceipt({
-  zapRequest,
-  preimage,
-  bolt11,
-  paidAt
-}) {
+function makeZapReceipt({ zapRequest, preimage, bolt11, paidAt }) {
   let zr = JSON.parse(zapRequest);
   let tagsFromZapRequest = zr.tags.filter(
     ([t]) => t === "e" || t === "p" || t === "a"
@@ -1369,8 +1343,8 @@ function makeZapReceipt({
     tags: [
       ...tagsFromZapRequest,
       ["bolt11", bolt11],
-      ["description", zapRequest]
-    ]
+      ["description", zapRequest],
+    ],
   };
   if (preimage) {
     zap.tags.push(["preimage", preimage]);
@@ -1382,5 +1356,11 @@ function makeZapReceipt({
 var secp256k17 = __toESM(require("@noble/secp256k1"));
 var import_hmac = require("@noble/hashes/hmac");
 var import_sha2563 = require("@noble/hashes/sha256");
-secp256k17.utils.hmacSha256Sync = (key, ...msgs) => (0, import_hmac.hmac)(import_sha2563.sha256, key, secp256k17.utils.concatBytes(...msgs));
-secp256k17.utils.sha256Sync = (...msgs) => (0, import_sha2563.sha256)(secp256k17.utils.concatBytes(...msgs));
+secp256k17.utils.hmacSha256Sync = (key, ...msgs) =>
+  (0, import_hmac.hmac)(
+    import_sha2563.sha256,
+    key,
+    secp256k17.utils.concatBytes(...msgs)
+  );
+secp256k17.utils.sha256Sync = (...msgs) =>
+  (0, import_sha2563.sha256)(secp256k17.utils.concatBytes(...msgs));
